<div
  class="code-block code-block-1"
  style="margin: 8px 8px 8px 0; float: left"
></div>
<p class="cpp-section" data-ezoic-video-excluded="1">Chapter introduction</p>
<p>
  This chapter builds on top of the concepts from lesson
  <a
    href="https://www.learncpp.com/cpp-tutorial/introduction-to-literals-and-operators/"
    >1.9 -- Introduction to literals and operators</a
  >. A quick review follows:
</p>
<p>
  An <strong>operation</strong> is a mathematical process involving zero or more
  input values (called <strong>operands</strong>) that produces a new value
  (called an output value). The specific operation to be performed is denoted by
  a construct (typically a symbol or pair of symbols) called an
  <strong>operator</strong>.
</p>
<p>
  For example, as children we all learn that <code>2 + 3</code> equals
  <code>5</code>. In this case, the literals <code>2</code> and
  <code>3</code> are the operands, and the symbol <code>+</code> is the operator
  that tells us to apply mathematical addition on the operands to produce the
  new value <code>5</code>. Because there is only one operator being used here,
  this is straightforward.
</p>
<p>
  In this chapter, we’ll discuss topics related to operators, and explore many
  of the common operators that C++ supports.
</p>
<p
  class="cpp-section cpp-topline"
  style="clear: both"
  data-ezoic-video-excluded="1"
>
  Evaluation of compound expressions
</p>
<p>
  Now, let’s consider a compound expression, such as <code>4 + 2 * 3</code>.
  Should this be grouped as <code>(4 + 2) * 3</code> which evaluates to
  <code>18</code>, or <code>4 + (2 * 3)</code> which evaluates to
  <code>10</code>? Using normal mathematical precedence rules (which state that
  multiplication is resolved before addition), we know that the above expression
  should be grouped as <code>4 + (2 * 3)</code> to produce the value
  <code>10</code>. But how does the compiler know?
</p>
<div class="code-block code-block-2" style="margin: 8px 0; clear: both"></div>
<p>In order to evaluate an expression, the compiler must do two things:</p>
<ul>
  <li>
    At compile time, the compiler must parse the expression and determine how
    operands are grouped with operators. This is done via the precedence and
    associativity rules, which we’ll discuss momentarily.
  </li>
  <li>
    At compile time or runtime, the operands are evaluated and operations
    executed to produce a result.
  </li>
</ul>
<p
  class="cpp-section cpp-topline"
  style="clear: both"
  data-ezoic-video-excluded="1"
>
  Operator precedence
</p>
<p>
  To assist with parsing a compound expression, all operators are assigned a
  level of precedence. Operators with a higher <strong>precedence</strong> level
  are grouped with operands first.
</p>
<p>
  You can see in the table below that multiplication and division (precedence
  level 5) have a higher precedence level than addition and subtraction
  (precedence level 6). Thus, multiplication and division will be grouped with
  operands before addition and subtraction. In other words,
  <code>4 + 2 * 3</code> will be grouped as <code>4 + (2 * 3)</code>.
</p>
<p
  class="cpp-section cpp-topline"
  style="clear: both"
  data-ezoic-video-excluded="1"
>
  Operator associativity
</p>
<p>
  Consider a compound expression like <code>7 - 4 - 1</code>. Should this be
  grouped as <code>(7 - 4) - 1</code> which evaluates to <code>2</code>, or
  <code>7 - (4 - 1)</code>, which evaluates to <code>4</code>? Since both
  subtraction operators have the same precedence level, the compiler can not use
  precedence alone to determine how this should be grouped.
</p>
<p>
  If two operators with the same precedence level are adjacent to each other in
  an expression, the operator’s <strong>associativity</strong> tells the
  compiler whether to evaluate the operators (not the operands!) from left to
  right or from right to left. Subtraction has precedence level 6, and the
  operators in precedence level 6 have an associativity of left to right. So
  this expression is grouped from left to right: <code>(7 - 4) - 1</code>.
</p>
<div class="code-block code-block-3" style="margin: 8px 0; clear: both"></div>
<p
  class="cpp-section cpp-topline"
  style="clear: both"
  data-ezoic-video-excluded="1"
>
  Table of operator precedence and associativity
</p>
<p>
  The below table is primarily meant to be a reference chart that you can refer
  back to in the future to resolve any precedence or associativity questions you
  have.
</p>
<p>Notes:</p>
<ul>
  <li>
    Precedence level 1 is the highest precedence level, and level 17 is the
    lowest. Operators with a higher precedence level have their operands grouped
    first.
  </li>
  <li>L-&gt;R means left to right associativity.</li>
  <li>R-&gt;L means right to left associativity.</li>
</ul>
<div class="cpp-table-wrapper" data-ezoic-video-excluded="1">
  <p></p>
  <p></p>
  <table class="cpp-table" data-ezoic-video-excluded="1">
    <tbody>
      <tr>
        <th>Prec/Ass</th>
        <th>Operator</th>
        <th>Description</th>
        <th>Pattern</th>
      </tr>
      <tr>
        <td>1 L-&gt;R</td>
        <td>::<br />::</td>
        <td>Global scope (unary)<br />Namespace scope (binary)</td>
        <td>::name<br />class_name::member_name<br /></td>
      </tr>
      <tr>
        <td>2 L-&gt;R</td>
        <td>
          ()<br />()<br />type()<br />type{}<br />[]<br />.<br />-&gt;<br />++<br />––<br />typeid<br />const_cast<br />dynamic_cast<br />reinterpret_cast<br />static_cast<br />sizeof…<br />noexcept<br />alignof
        </td>
        <td>
          Parentheses<br />Function call<br />Functional cast<br />List init
          temporary object (C++11)<br />Array subscript<br />Member access from
          object<br />Member access from object ptr<br />Post-increment<br />Post-decrement<br />Run-time
          type information<br />Cast away const<br />Run-time type-checked
          cast<br />Cast one type to another<br />Compile-time type-checked
          cast<br />Get parameter pack size<br />Compile-time exception check<br />Get
          type alignment
        </td>
        <td>
          (expression)<br />function_name(arguments)<br />type(expression)<br />type{expression}<br />pointer[expression]<br />object.member_name<br />object_pointer-&gt;member_name<br />lvalue++<br />lvalue––<br />typeid(type)
          or typeid(expression)<br />const_cast&lt;type&gt;(expression)<br />dynamic_cast&lt;type&gt;(expression)<br />reinterpret_cast&lt;type&gt;(expression)<br />static_cast&lt;type&gt;(expression)<br />sizeof…(expression)<br />noexcept(expression)<br />alignof(type)
        </td>
      </tr>
      <tr>
        <td>3 R-&gt;L</td>
        <td>
          +<br />-<br />++<br />––<br />!<br />not<br />~<br />(type)<br />sizeof<br />co_await<br />&amp;<br />*<br />new<br />new[]<br />delete<br />delete[]
        </td>
        <td>
          Unary plus<br />Unary minus<br />Pre-increment<br />Pre-decrement<br />Logical
          NOT<br />Logical NOT<br />Bitwise NOT<br />C-style cast<br />Size in
          bytes<br />Await asynchronous call<br />Address of<br />Dereference<br />Dynamic
          memory allocation<br />Dynamic array allocation<br />Dynamic memory
          deletion<br />Dynamic array deletion
        </td>
        <td>
          +expression<br />-expression<br />++lvalue<br />––lvalue<br />!expression<br />not
          expression<br />~expression<br />(new_type)expression<br />sizeof(type)
          or sizeof(expression)<br />co_await expression (C++20)<br />&amp;lvalue<br />*expression<br />new
          type<br />new type[expression]<br />delete pointer<br />delete[]
          pointer
        </td>
      </tr>
      <tr>
        <td>4 L-&gt;R</td>
        <td>-&gt;*<br />.*</td>
        <td>Member pointer selector<br />Member object selector</td>
        <td>
          object_pointer-&gt;*pointer_to_member<br />object.*pointer_to_member
        </td>
      </tr>
      <tr>
        <td>5 L-&gt;R</td>
        <td>*<br />/<br />%</td>
        <td>Multiplication<br />Division<br />Remainder</td>
        <td>
          expression * expression<br />expression / expression<br />expression %
          expression
        </td>
      </tr>
      <tr>
        <td>6 L-&gt;R</td>
        <td>+<br />-</td>
        <td>Addition<br />Subtraction</td>
        <td>expression + expression<br />expression - expression</td>
      </tr>
      <tr>
        <td>7 L-&gt;R</td>
        <td>&lt;&lt;<br />&gt;&gt;</td>
        <td>
          Bitwise shift left / Insertion<br />Bitwise shift right / Extraction
        </td>
        <td>
          expression &lt;&lt; expression<br />expression &gt;&gt; expression
        </td>
      </tr>
      <tr>
        <td>8 L-&gt;R</td>
        <td>&lt;=&gt;</td>
        <td>Three-way comparison (C++20)</td>
        <td>expression &lt;=&gt; expression</td>
      </tr>
      <tr>
        <td>9 L-&gt;R</td>
        <td>&lt;<br />&lt;=<br />&gt;<br />&gt;=</td>
        <td>
          Comparison less than<br />Comparison less than or equals<br />Comparison
          greater than<br />Comparison greater than or equals
        </td>
        <td>
          expression &lt; expression<br />expression &lt;= expression<br />expression
          &gt; expression<br />expression &gt;= expression
        </td>
      </tr>
      <tr>
        <td>10 L-&gt;R</td>
        <td>==<br />!=</td>
        <td>Equality<br />Inequality</td>
        <td>expression == expression<br />expression != expression</td>
      </tr>
      <tr>
        <td>11 L-&gt;R</td>
        <td>&amp;</td>
        <td>Bitwise AND</td>
        <td>expression &amp; expression</td>
      </tr>
      <tr>
        <td>12 L-&gt;R</td>
        <td>^</td>
        <td>Bitwise XOR</td>
        <td>expression ^ expression</td>
      </tr>
      <tr>
        <td>13 L-&gt;R</td>
        <td>|</td>
        <td>Bitwise OR</td>
        <td>expression | expression</td>
      </tr>
      <tr>
        <td>14 L-&gt;R</td>
        <td>&amp;&amp;<br />and</td>
        <td>Logical AND<br />Logical AND</td>
        <td>
          expression &amp;&amp; expression<br />expression and expression
          <p></p>
        </td>
      </tr>
      <tr>
        <td>15 L-&gt;R</td>
        <td>||<br />or</td>
        <td>Logical OR<br />Logical OR</td>
        <td>expression || expression<br />expression or expression</td>
      </tr>
      <tr>
        <td>16 R-&gt;L</td>
        <td>
          throw<br />co_yield<br />?:<br />=<br />*=<br />/=<br />%=<br />+=<br />-=<br />&lt;&lt;=<br />&gt;&gt;=<br />&amp;=<br />|=<br />^=
        </td>
        <td>
          Throw expression<br />Yield expression (C++20)<br />Conditional<br />Assignment<br />Multiplication
          assignment<br />Division assignment<br />Remainder assignment<br />Addition
          assignment<br />Subtraction assignment<br />Bitwise shift left
          assignment<br />Bitwise shift right assignment<br />Bitwise AND
          assignment<br />Bitwise OR assignment<br />Bitwise XOR assignment
        </td>
        <td>
          throw expression<br />co_yield expression<br />expression ? expression
          : expression<br />lvalue = expression<br />lvalue *= expression<br />lvalue
          /= expression<br />lvalue %= expression<br />lvalue += expression<br />lvalue
          -= expression<br />lvalue &lt;&lt;= expression<br />lvalue &gt;&gt;=
          expression<br />lvalue &amp;= expression<br />lvalue |= expression<br />lvalue
          ^= expression
        </td>
      </tr>
      <tr>
        <td>17 L-&gt;R</td>
        <td>,</td>
        <td>Comma operator</td>
        <td>expression, expression</td>
      </tr>
    </tbody>
  </table>
</div>
<p>
  You should already recognize a few of these operators, such as <code>+</code>,
  <code>-</code>, <code>*</code>, <code>/</code>, <code>()</code>, and
  <code>sizeof</code>. However, unless you have experience with another
  programming language, the majority of the operators in this table will
  probably be incomprehensible to you right now. That’s expected at this point.
  We’ll cover many of them in this chapter, and the rest will be introduced as
  there is a need for them.
</p>
<div class="cpp-note cpp-lightbluebackground" data-ezoic-video-excluded="1">
  <p class="cpp-note-title cpp-bottomline">
    Q: Where is the exponent operator?
  </p>
  <p>
    C++ doesn’t include an operator to do exponentiation (<code>operator^</code>
    has a different function in C++). We discuss exponentiation more in lesson
    <a
      href="https://www.learncpp.com/cpp-tutorial/remainder-and-exponentiation/"
      >6.3 -- Remainder and Exponentiation</a
    >.
  </p>
</div>
<p>
  Note that <code>operator&lt;&lt;</code> handles both bitwise left shift and
  insertion, and <code>operator&gt;&gt;</code> handles both bitwise right shift
  and extraction. The compiler can determine which operation to perform based on
  the types of the operands.
</p>
<p
  class="cpp-section cpp-topline"
  style="clear: both"
  data-ezoic-video-excluded="1"
>
  Parenthesization
</p>
<p>
  Due to the precedence rules, <code>4 + 2 * 3</code> will be grouped as
  <code>4 + (2 * 3)</code>. But what if we actually meant
  <code>(4 + 2) * 3</code>? Just like in normal mathematics, in C++ we can
  explicitly use parentheses to set the grouping of operands as we desire. This
  works because parentheses have one of the highest precedence levels, so
  parentheses generally evaluate before whatever is inside them.
</p>
<div class="code-block code-block-4" style="margin: 8px 0; clear: both"></div>
<p
  class="cpp-section cpp-topline"
  style="clear: both"
  data-ezoic-video-excluded="1"
>
  Use parenthesis to make compound expressions easier to understand
</p>
<p>
  Now consider an expression like <code>x &amp;&amp; y || z</code>. Does this
  evaluate as <code>(x &amp;&amp; y) || z</code> or
  <code>x &amp;&amp; (y || z)</code>? You could look up in the table and see
  that <code>&amp;&amp;</code> takes precedence over <code>||</code>. But there
  are so many operators and precedence levels that it’s hard to remember them
  all. And you don’t want to have to look up operators all the time to
  understand how a compound expression evaluates.
</p>
<p>
  In order to reduce mistakes and make your code easier to understand without
  referencing a precedence table, it’s a good idea to parenthesize any
  non-trivial compound expression, so it’s clear what your intent is.
</p>
<div class="cpp-note cpp-lightgreenbackground" data-ezoic-video-excluded="1">
  <p class="cpp-note-title cpp-bottomline">Best practice</p>
  <p>
    Use parentheses to make it clear how a non-trivial compound expression
    should evaluate (even if they are technically unnecessary).
  </p>
</div>
<p>
  A good rule of thumb is: Parenthesize everything, except addition,
  subtraction, multiplication, and division.
</p>
<p>
  There is one additional exception to the above best practice: Expressions that
  have a single assignment operator (and no comma operator) do not need to have
  the right operand of the assignment wrapped in parenthesis.
</p>
<div class="code-block code-block-5" style="margin: 8px 0; clear: both"></div>
<p>For example:</p>
<div class="code-toolbar">
  <pre
    class="line-numbers language-cpp"
    tabindex="0"
  ><code class="match-braces language-cpp">x <span class="token operator">=</span> <span class="token punctuation brace-round brace-open brace-level-1" id="pair-99-close">(</span>y <span class="token operator">+</span> z <span class="token operator">+</span> w<span class="token punctuation brace-round brace-close brace-level-1" id="pair-99-open">)</span><span class="token punctuation">;</span>   <span class="token comment">// instead of this</span>
x <span class="token operator">=</span> y <span class="token operator">+</span> z <span class="token operator">+</span> w<span class="token punctuation">;</span>     <span class="token comment">// it's okay to do this</span>

x <span class="token operator">=</span> <span class="token punctuation brace-round brace-open brace-level-1" id="pair-101-close">(</span><span class="token punctuation brace-round brace-open brace-level-2" id="pair-100-close">(</span>y <span class="token operator">||</span> z<span class="token punctuation brace-round brace-close brace-level-2" id="pair-100-open">)</span> <span class="token operator">&amp;&amp;</span> w<span class="token punctuation brace-round brace-close brace-level-1" id="pair-101-open">)</span><span class="token punctuation">;</span> <span class="token comment">// instead of this</span>
x <span class="token operator">=</span> <span class="token punctuation brace-round brace-open brace-level-1" id="pair-102-close">(</span>y <span class="token operator">||</span> z<span class="token punctuation brace-round brace-close brace-level-1" id="pair-102-open">)</span> <span class="token operator">&amp;&amp;</span> w<span class="token punctuation">;</span>   <span class="token comment">// it's okay to do this</span>

x <span class="token operator">=</span> <span class="token punctuation brace-round brace-open brace-level-1" id="pair-103-close">(</span>y <span class="token operator">*=</span> z<span class="token punctuation brace-round brace-close brace-level-1" id="pair-103-open">)</span><span class="token punctuation">;</span> <span class="token comment">// expressions with multiple assignments still benefit from parenthesis</span><span aria-hidden="true" class="line-numbers-rows"><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span></span><span class="line-numbers-sizer" style="display: none;"></span></code></pre>
  <div class="toolbar">
    <div class="toolbar-item">
      <button
        class="copy-to-clipboard-button"
        type="button"
        data-copy-state="copy"
      >
        <span>Copy</span>
      </button>
    </div>
  </div>
</div>
<p>
  The assignment operators have the second lowest precedence (only the comma
  operator is lower, and it’s rarely used). Therefore, so long as there is only
  one assignment (and no commas), we know the right operand will fully evaluate
  before the assignment.
</p>
<div class="cpp-note cpp-lightgreenbackground" data-ezoic-video-excluded="1">
  <p class="cpp-note-title cpp-bottomline">Best practice</p>
  <p>
    Expressions with a single assignment operator do not need to have the right
    operand of the assignment wrapped in parenthesis.
  </p>
</div>
<p
  class="cpp-section cpp-topline"
  style="clear: both"
  data-ezoic-video-excluded="1"
>
  Value computation of operations
</p>
<p>
  The C++ standard uses the term <strong>value computation</strong> to mean the
  execution of operators in an expression to produce a value. The precedence and
  association rules determine the order in which value computation happens.
</p>
<p>
  For example, given the expression <code>4 + 2 * 3</code>, due to the
  precedence rules this groups as <code>4 + (2 * 3)</code>. The value
  computation for <code>(2 * 3)</code> must happen first, so that the value
  computation for <code>4 + 6</code> can be completed.
</p>
<p
  class="cpp-section cpp-topline"
  style="clear: both"
  data-ezoic-video-excluded="1"
>
  Evaluation of operands
</p>
<p>
  The C++ standard (mostly) uses the term <strong>evaluation</strong> to refer
  to the evaluation of operands (not the evaluation of operators or
  expressions!). For example, given expression <code>a + b</code>,
  <code>a</code> will be evaluated to produce some value, and
  <code>b</code> will be evaluated to produce some value. These values can be
  then used as operands to <code>operator+</code> for value computation.
</p>
<div class="cpp-note cpp-lightgraybackground" data-ezoic-video-excluded="1">
  <p class="cpp-note-title cpp-bottomline">Nomenclature</p>
  <p>
    Informally, we typically use the term “evaluates” to mean the evaluation of
    an entire expression (value computation), not just the operands of an
    expression.
  </p>
</div>
<p
  class="cpp-section cpp-topline"
  style="clear: both"
  data-ezoic-video-excluded="1"
>
  <a name="unspecified"></a>The order of evaluation of operands (including
  function arguments) is mostly unspecified
  <a href="#unspecified"><i class="fa fa-link" style="font-size: 0.8em"></i></a>
</p>
<div class="code-block code-block-6" style="margin: 8px 0; clear: both"></div>
<p>
  In most cases, the order of evaluation for operands and function arguments is
  unspecified, meaning they may be evaluated in any order.
</p>
<p>Consider the following expression:</p>
<div class="code-toolbar">
  <pre
    class="line-numbers language-cpp"
    tabindex="0"
  ><code class="match-braces language-cpp">a <span class="token operator">*</span> b <span class="token operator">+</span> c <span class="token operator">*</span> d<span aria-hidden="true" class="line-numbers-rows"><span style="height: 16px;"></span></span><span class="line-numbers-sizer" style="display: none;"></span></code></pre>
  <div class="toolbar">
    <div class="toolbar-item">
      <button
        class="copy-to-clipboard-button"
        type="button"
        data-copy-state="copy"
      >
        <span>Copy</span>
      </button>
    </div>
  </div>
</div>
<p>
  We know from the precedence and associativity rules above that this expression
  will be grouped as if we had typed:
</p>
<div class="code-toolbar">
  <pre
    class="line-numbers language-cpp"
    tabindex="0"
  ><code class="match-braces language-cpp"><span class="token punctuation brace-round brace-open brace-level-1" id="pair-104-close">(</span>a <span class="token operator">*</span> b<span class="token punctuation brace-round brace-close brace-level-1" id="pair-104-open">)</span> <span class="token operator">+</span> <span class="token punctuation brace-round brace-open brace-level-1" id="pair-105-close">(</span>c <span class="token operator">*</span> d<span class="token punctuation brace-round brace-close brace-level-1" id="pair-105-open">)</span><span aria-hidden="true" class="line-numbers-rows"><span style="height: 16px;"></span></span><span class="line-numbers-sizer" style="display: none;"></span></code></pre>
  <div class="toolbar">
    <div class="toolbar-item">
      <button
        class="copy-to-clipboard-button"
        type="button"
        data-copy-state="copy"
      >
        <span>Copy</span>
      </button>
    </div>
  </div>
</div>
<p>
  If <code>a</code> is <code>1</code>, <code>b</code> is <code>2</code>,
  <code>c</code> is <code>3</code>, and <code>d</code> is <code>4</code>, this
  expression will always compute the value <code>14</code>.
</p>
<p>
  However, the precedence and associativity rules only tell us how operators and
  operands are grouped and the order in which value computation will occur. They
  do not tell us the order in which the operands or subexpressions are
  evaluated. The compiler is free to evaluate operands <code>a</code>,
  <code>b</code>, <code>c</code>, or <code>d</code> in any order. The compiler
  is also free to calculate <code>a * b</code> or <code>c * d</code> first.
</p>
<p>
  For most expressions, this is irrelevant. In our sample expression above, it
  doesn’t matter in which order variables <code>a</code>, <code>b</code>,
  <code>c</code>, or <code>d</code> are evaluated for their values: the value
  calculated will always be <code>14</code>. There is no ambiguity here.
</p>
<div class="code-block code-block-7" style="margin: 8px 0; clear: both"></div>
<p>
  But it is possible to write expressions where the order of evaluation does
  matter. Consider this program, which contains a mistake often made by new C++
  programmers:
</p>
<div class="code-toolbar">
  <pre
    class="line-numbers language-cpp"
    tabindex="0"
  ><code class="match-braces language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword keyword-int">int</span> <span class="token function">getValue</span><span class="token punctuation brace-round brace-open brace-level-1" id="pair-106-close">(</span><span class="token punctuation brace-round brace-close brace-level-1" id="pair-106-open">)</span>
<span class="token punctuation brace-curly brace-open brace-level-1" id="pair-115-close">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Enter an integer: "</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-int">int</span> x<span class="token punctuation brace-curly brace-open brace-level-2" id="pair-114-close">{</span><span class="token punctuation brace-curly brace-close brace-level-2" id="pair-114-open">}</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cin <span class="token operator">&gt;&gt;</span> x<span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation brace-curly brace-close brace-level-1" id="pair-115-open">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">printCalculation</span><span class="token punctuation brace-round brace-open brace-level-1" id="pair-107-close">(</span><span class="token keyword keyword-int">int</span> x<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> y<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> z<span class="token punctuation brace-round brace-close brace-level-1" id="pair-107-open">)</span>
<span class="token punctuation brace-curly brace-open brace-level-1" id="pair-116-close">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">+</span> <span class="token punctuation brace-round brace-open brace-level-2" id="pair-108-close">(</span>y <span class="token operator">*</span> z<span class="token punctuation brace-round brace-close brace-level-2" id="pair-108-open">)</span><span class="token punctuation">;</span>
<span class="token punctuation brace-curly brace-close brace-level-1" id="pair-116-open">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation brace-round brace-open brace-level-1" id="pair-109-close">(</span><span class="token punctuation brace-round brace-close brace-level-1" id="pair-109-open">)</span>
<span class="token punctuation brace-curly brace-open brace-level-1" id="pair-117-close">{</span>
    <span class="token function">printCalculation</span><span class="token punctuation brace-round brace-open brace-level-2" id="pair-113-close">(</span><span class="token function">getValue</span><span class="token punctuation brace-round brace-open brace-level-3" id="pair-110-close">(</span><span class="token punctuation brace-round brace-close brace-level-3" id="pair-110-open">)</span><span class="token punctuation">,</span> <span class="token function">getValue</span><span class="token punctuation brace-round brace-open brace-level-3" id="pair-111-close">(</span><span class="token punctuation brace-round brace-close brace-level-3" id="pair-111-open">)</span><span class="token punctuation">,</span> <span class="token function">getValue</span><span class="token punctuation brace-round brace-open brace-level-3" id="pair-112-close">(</span><span class="token punctuation brace-round brace-close brace-level-3" id="pair-112-open">)</span><span class="token punctuation brace-round brace-close brace-level-2" id="pair-113-open">)</span><span class="token punctuation">;</span> <span class="token comment">// this line is ambiguous</span>

    <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation brace-curly brace-close brace-level-1" id="pair-117-open">}</span><span aria-hidden="true" class="line-numbers-rows"><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span></span><span class="line-numbers-sizer" style="display: none;"></span></code></pre>
  <div class="toolbar">
    <div class="toolbar-item">
      <button
        class="copy-to-clipboard-button"
        type="button"
        data-copy-state="copy"
      >
        <span>Copy</span>
      </button>
    </div>
  </div>
</div>
<p>
  If you run this program and enter the inputs <code>1</code>, <code>2</code>,
  and <code>3</code>, you might assume that this program would calculate
  <code>1 + (2 * 3)</code> and print <code>7</code>. But that is making the
  assumption that the arguments to <code>printCalculation()</code> will evaluate
  in left-to-right order (so parameter <code>x</code> gets value <code>1</code>,
  <code>y</code> gets value <code>2</code>, and <code>z</code> gets value
  <code>3</code>). If instead, the arguments evaluate in right-to-left order (so
  parameter <code>z</code> gets value <code>1</code>, <code>y</code> gets value
  <code>2</code>, and <code>x</code> gets value <code>3</code>), then the
  program will print <code>5</code> instead.
</p>
<div class="cpp-note cpp-lightbluebackground" data-ezoic-video-excluded="1">
  <p class="cpp-note-title cpp-bottomline">Tip</p>
  <p>
    The Clang compiler evaluates arguments in left-to-right order. The GCC
    compiler evaluates arguments in right-to-left order.
  </p>
  <p>
    If you’d like to see this behavior for yourself, you can do so on
    <a href="https://wandbox.org/#">Wandbox</a>. Paste in the above program,
    enter <code>1 2 3</code> in the <em>Stdin</em> tab, select GCC or Clang, and
    then compile the program. The output will appear at the bottom of the page
    (you may have to scroll down to see it). You will note that the output for
    GCC and Clang differs!
  </p>
</div>
<p>
  The above program can be made unambiguous by making each function call to
  <code>getValue()</code> a separate statement:
</p>
<div class="code-toolbar">
  <pre
    class="line-numbers language-cpp"
    tabindex="0"
  ><code class="match-braces language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword keyword-int">int</span> <span class="token function">getValue</span><span class="token punctuation brace-round brace-open brace-level-1" id="pair-118-close">(</span><span class="token punctuation brace-round brace-close brace-level-1" id="pair-118-open">)</span>
<span class="token punctuation brace-curly brace-open brace-level-1" id="pair-127-close">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Enter an integer: "</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-int">int</span> x<span class="token punctuation brace-curly brace-open brace-level-2" id="pair-126-close">{</span><span class="token punctuation brace-curly brace-close brace-level-2" id="pair-126-open">}</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cin <span class="token operator">&gt;&gt;</span> x<span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation brace-curly brace-close brace-level-1" id="pair-127-open">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">printCalculation</span><span class="token punctuation brace-round brace-open brace-level-1" id="pair-119-close">(</span><span class="token keyword keyword-int">int</span> x<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> y<span class="token punctuation">,</span> <span class="token keyword keyword-int">int</span> z<span class="token punctuation brace-round brace-close brace-level-1" id="pair-119-open">)</span>
<span class="token punctuation brace-curly brace-open brace-level-1" id="pair-128-close">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">+</span> <span class="token punctuation brace-round brace-open brace-level-2" id="pair-120-close">(</span>y <span class="token operator">*</span> z<span class="token punctuation brace-round brace-close brace-level-2" id="pair-120-open">)</span><span class="token punctuation">;</span>
<span class="token punctuation brace-curly brace-close brace-level-1" id="pair-128-open">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation brace-round brace-open brace-level-1" id="pair-121-close">(</span><span class="token punctuation brace-round brace-close brace-level-1" id="pair-121-open">)</span>
<span class="token punctuation brace-curly brace-open brace-level-1" id="pair-132-close">{</span>
    <span class="token keyword keyword-int">int</span> a<span class="token punctuation brace-curly brace-open brace-level-2" id="pair-129-close">{</span> <span class="token function">getValue</span><span class="token punctuation brace-round brace-open brace-level-3" id="pair-122-close">(</span><span class="token punctuation brace-round brace-close brace-level-3" id="pair-122-open">)</span> <span class="token punctuation brace-curly brace-close brace-level-2" id="pair-129-open">}</span><span class="token punctuation">;</span> <span class="token comment">// will execute first</span>
    <span class="token keyword keyword-int">int</span> b<span class="token punctuation brace-curly brace-open brace-level-2" id="pair-130-close">{</span> <span class="token function">getValue</span><span class="token punctuation brace-round brace-open brace-level-3" id="pair-123-close">(</span><span class="token punctuation brace-round brace-close brace-level-3" id="pair-123-open">)</span> <span class="token punctuation brace-curly brace-close brace-level-2" id="pair-130-open">}</span><span class="token punctuation">;</span> <span class="token comment">// will execute second</span>
    <span class="token keyword keyword-int">int</span> c<span class="token punctuation brace-curly brace-open brace-level-2" id="pair-131-close">{</span> <span class="token function">getValue</span><span class="token punctuation brace-round brace-open brace-level-3" id="pair-124-close">(</span><span class="token punctuation brace-round brace-close brace-level-3" id="pair-124-open">)</span> <span class="token punctuation brace-curly brace-close brace-level-2" id="pair-131-open">}</span><span class="token punctuation">;</span> <span class="token comment">// will execute third</span>

    <span class="token function">printCalculation</span><span class="token punctuation brace-round brace-open brace-level-2" id="pair-125-close">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation brace-round brace-close brace-level-2" id="pair-125-open">)</span><span class="token punctuation">;</span> <span class="token comment">// this line is now unambiguous</span>

    <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation brace-curly brace-close brace-level-1" id="pair-132-open">}</span><span aria-hidden="true" class="line-numbers-rows"><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span><span style="height: 16px;"></span></span><span class="line-numbers-sizer" style="display: none;"></span></code></pre>
  <div class="toolbar">
    <div class="toolbar-item">
      <button
        class="copy-to-clipboard-button"
        type="button"
        data-copy-state="copy"
      >
        <span>Copy</span>
      </button>
    </div>
  </div>
</div>
<p>
  In this version, <code>a</code> will always have value <code>1</code>,
  <code>b</code> will have value <code>2</code>, and <code>c</code> will have
  value <code>3</code>. When the arguments to
  <code>printCalculation()</code> are evaluated, it doesn’t matter which order
  the argument evaluation happens in -- parameter <code>x</code> will always get
  value <code>1</code>, <code>y</code> will get value <code>2</code>, and
  <code>z</code> will get value <code>3</code>. This version will
  deterministically print <code>7</code>.
</p>
<div class="cpp-note cpp-lightbluebackground" data-ezoic-video-excluded="1">
  <p class="cpp-note-title cpp-bottomline">Key insight</p>
  <p>
    Operands, function arguments, and subexpressions may be evaluated in any
    order.
  </p>
  <p>
    It is a common mistake to believe that operator precedence and associativity
    affects order of evaluation. Precedence and associativity is used only to
    determine how operands are grouped with operators, and the order of value
    computation.
  </p>
</div>
<div class="cpp-note cpp-lightredbackground" data-ezoic-video-excluded="1">
  <p class="cpp-note-title cpp-bottomline">Warning</p>
  <p>
    Ensure that the expressions (or function calls) you write are not dependent
    on operand (or argument) evaluation order.
  </p>
</div>
<div class="cpp-note cpp-lightgraybackground" data-ezoic-video-excluded="1">
  <p class="cpp-note-title cpp-bottomline">Related content</p>
  <p>
    Operators with side effects can also cause unexpected evaluation results. We
    cover this in lesson
    <a
      href="https://www.learncpp.com/cpp-tutorial/increment-decrement-operators-and-side-effects/"
      >6.4 -- Increment/decrement operators, and side effects</a
    >.
  </p>
</div>
<p
  class="cpp-section cpp-topline"
  style="clear: both"
  data-ezoic-video-excluded="1"
>
  Quiz time
</p>
<div class="quiz" style="clear: both">
  <p class="quiz-header">Question #1</p>
  <p>
    You know from everyday mathematics that expressions inside of parentheses
    get evaluated first. For example, in the expression
    <code>(2 + 3) * 4</code>, the <code>(2 + 3)</code> part is evaluated first.
  </p>
  <p>
    For this exercise, you are given a set of expressions that have no
    parentheses. Using the operator precedence and associativity rules in the
    table above, add parentheses to each expression to make it clear how the
    compiler will evaluate the expression.
  </p>
  <p>
    <a
      class="hint_link_show"
      href="javascript:void(0)"
      onclick="cppHintToggle(document.getElementById('cpp_hint_id_0'),this,'Show Hint','')"
      >Show Hint</a
    >
  </p>
  <div
    class="wphint"
    id="cpp_hint_id_0"
    style="display: none; margin-bottom: 1em"
  >
    Hint: Use the pattern column in the table above to determine whether the
    operator is unary (has one operand) or binary (has two operands). Review the
    lesson
    <a
      href="https://www.learncpp.com/cpp-tutorial/introduction-to-literals-and-operators/"
      >1.9 -- Introduction to literals and operators</a
    >
    if you need a refresher on what unary and binary operators are.
  </div>
  <div class="cpp-table-wrapper" data-ezoic-video-excluded="1">
    <p></p>
    <p></p>
    <table class="cpp-table" data-ezoic-video-excluded="1">
      <tbody>
        <tr>
          <td>
            Sample problem: x = 2 + 3 % 4
            <p></p>
            <p>
              Binary operator <code>%</code> has higher precedence than operator
              <code>+</code> or operator <code>=</code>, so it gets evaluated
              first:
            </p>
            <p>x = 2 + (3 % 4)</p>
            <p>
              Binary operator <code>+</code> has a higher precedence than
              operator <code>=</code>, so it gets evaluated next:
            </p>
            <p>Final answer: x = (2 + (3 % 4))</p>
            <p>
              We now no longer need the table above to understand how this
              expression will evaluate.
            </p>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <p>a) x = 3 + 4 + 5;</p>
  <p>
    <a
      class="solution_link_show"
      href="javascript:void(0)"
      onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')"
      >Show Solution</a
    >
  </p>
  <div class="wpsolution" id="cpp_solution_id_0" style="display: none">
    <p>
      Binary operator <code>+</code> has higher precedence than <code>=</code>:
    </p>
    <p>x = (3 + 4 + 5);</p>
    <p>Binary operator <code>+</code> has left to right association:</p>
    <p>Final answer: x = ((3 + 4) + 5);</p>
  </div>
  <p>b) x = y = z;</p>
  <p>
    <a
      class="solution_link_show"
      href="javascript:void(0)"
      onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')"
      >Show Solution</a
    >
  </p>
  <div class="wpsolution" id="cpp_solution_id_1" style="display: none">
    <p>Binary operator <code>=</code> has right to left association:</p>
    <p>Final answer: x = (y = z);</p>
  </div>
  <p>c) z *= ++y + 5;</p>
  <p>
    <a
      class="solution_link_show"
      href="javascript:void(0)"
      onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')"
      >Show Solution</a
    >
  </p>
  <div class="wpsolution" id="cpp_solution_id_2" style="display: none">
    <p>Unary operator <code>++</code> has the highest precedence:</p>
    <p>z *= (++y) + 5;</p>
    <p>Binary operator <code>+</code> has the next highest precedence:</p>
    <p>Final answer: z *= ((++y) + 5);</p>
  </div>
  <p>d) a || b &amp;&amp; c || d;</p>
  <p>
    <a
      class="solution_link_show"
      href="javascript:void(0)"
      onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'),this,'Show Solution','Hide Solution')"
      >Show Solution</a
    >
  </p>
  <div class="wpsolution" id="cpp_solution_id_3" style="display: none">
    <p>
      Binary operator <code>&amp;&amp;</code> has higher precedence than
      <code>||</code>:
    </p>
    <p>a || (b &amp;&amp; c) || d;</p>
    <p>Binary operator <code>||</code> has left to right association:</p>
    <p>Final answer: (a || (b &amp;&amp; c)) || d;</p>
  </div>
  <p></p>
</div>
<div class="prevnext">
  <div class="prevnext-inline">
    <a
      class="nav-link"
      href="https://www.learncpp.com/cpp-tutorial/arithmetic-operators/"
      ><div class="nav-button nav-button-next">
        <div class="nav-button-icon">
          <i class="fa fa-chevron-circle-right" aria-hidden="true"></i>
        </div>
        <div class="nav-button-text">
          <div class="nav-button-title">Next lesson</div>
          <div class="nav-button-lesson">
            <span class="nav-button-lesson-number">6.2</span>Arithmetic
            operators
          </div>
        </div>
      </div></a
    ><a class="nav-link" href="/"
      ><div class="nav-button nav-button-index">
        <div class="nav-button-icon">
          <i class="fa fa-home" aria-hidden="true"></i>
        </div>
        <div class="nav-button-text">
          <div class="nav-button-title">Back to table of contents</div>
        </div>
      </div></a
    ><a
      class="nav-link"
      href="https://www.learncpp.com/cpp-tutorial/chapter-5-summary-and-quiz/"
      ><div class="nav-button nav-button-prev">
        <div class="nav-button-icon">
          <i class="fa fa-chevron-circle-left" aria-hidden="true"></i>
        </div>
        <div class="nav-button-text">
          <div class="nav-button-title">Previous lesson</div>
          <div class="nav-button-lesson">
            <span class="nav-button-lesson-number">5.x</span>Chapter 5 summary
            and quiz
          </div>
        </div>
      </div></a
    >
  </div>
</div>
<div class="code-block code-block-10" style="margin: 8px 0; clear: both"></div>
