<div
  class="code-block code-block-1"
  style="margin: 8px 8px 8px 0; float: left"
></div>
<p>
  Modern computers are incredibly fast, and getting faster all the time.
  However, computers also have some significant constraints: they only natively
  understand a limited set of instructions, and must be told exactly what to do.
</p>
<p>
  A <strong>computer program</strong> is a sequence of instructions that directs
  a computer to perform certain actions in a specified order. Computer programs
  are typically written in a <strong>programming language</strong>, which is a
  language designed to facilitate the writing of instructions for computers.
  There are many different programming languages available, each of which caters
  to a different set of needs. The act (and art) of writing a program is called
  <strong>programming</strong>. We’ll talk more specifically about how to create
  programs in C++ in upcoming lessons in this chapter.
</p>
<p>
  When a computer is performing the actions described by the instructions in a
  computer program, we say it is <strong>running</strong> or
  <strong>executing</strong> the program. A computer will not begin execution of
  a program until told to do so. That typically requires the user to
  <strong>launch</strong> (or <strong>run</strong> or <strong>execute</strong>)
  the program, although programs may also be launched by other programs.
</p>
<p>
  Programs are executed on the computer’s <strong>hardware</strong>, which
  consists of the physical components that make up a computer. Notable hardware
  found on a typical computing device includes:
</p>
<ul>
  <li>
    A CPU (central processing unit, often called the “brain” of the computer),
    which actually executes the instructions.
  </li>
  <li>Memory, where computer programs are loaded prior to execution.</li>
  <li>
    Interactive devices (e.g. a monitor, touch screen, keyboard, or mouse),
    which allow a person to interact with a computer.
  </li>
  <li>
    Storage devices (e.g. a hard drive, SSD, or flash memory), which retain
    information (including installed programs) even when the computer is turned
    off.
  </li>
</ul>
<p>
  In contrast, the term <strong>software</strong> broadly refers to the programs
  on a system that are designed to be executed on hardware.
</p>
<div class="code-block code-block-2" style="margin: 8px 0; clear: both"></div>
<p>
  In modern computing, programs often interact with more than just hardware --
  they also interact with other software on the system (particularly the
  operating system). The term <strong>platform</strong> refers to a compatible
  set of hardware and software (OS, browser, etc…) that provides an environment
  for software to run. For example, the term “PC” is used colloquially to mean
  the platform consisting of a Windows OS running on an x86-family CPU.
</p>
<p>
  Platforms often provide useful services for the programs running on them. For
  example, a desktop application might request the operating system give them a
  chunk of free memory, create a file over there, or play a sound. The running
  program doesn’t have to know how this is actually facilitated. If a program
  uses capabilities or services provided by the platform, it becomes dependent
  on that platform, and cannot be run on other platforms without modification. A
  program that can be easily transferred from one platform to another is said to
  be <strong>portable</strong>. The act of modifying a program so that it runs
  on a different platform is called <strong>porting</strong>.
</p>
<p>
  Now that we’ve talked about programs, let’s discuss programming languages.
  This isn’t just a history lesson, we’ll also be introducing terminology that
  will come up in future lessons.
</p>
<p
  class="cpp-section cpp-topline"
  style="clear: both"
  data-ezoic-video-excluded="1"
>
  Machine Language
</p>
<p>
  A computer’s CPU is incapable of understanding C++. Instead, CPUs are only
  capable of processing instructions written in
  <strong>machine language</strong> (or <strong>machine code</strong>). The set
  of all possible machine language instructions that a given CPU can understand
  is called an <strong>instruction set</strong>.
</p>
<p>
  Here is a sample machine language instruction: <code>10110000 01100001</code>.
</p>
<div class="code-block code-block-3" style="margin: 8px 0; clear: both"></div>
<p>
  Each instruction is understood by the CPU as a command to do a very specific
  job, such as “compare these two numbers”, or “copy this number into that
  memory location”. Back when computers were first invented, programmers had to
  write programs directly in machine language, which was a very difficult and
  time-consuming thing to do.
</p>
<p>
  How these instructions are organized and interpreted is beyond the scope of
  this tutorial series, but it is worth noting a few things.
</p>
<p>
  First, each instruction is composed of a sequence of 1s and 0s. Each
  individual 0 or 1 is called a <strong>binary digit</strong>, or
  <strong>bit</strong> for short. The number of bits in a machine language
  instruction varies -- for example, some CPUs process instructions that are
  always 32 bits long, whereas some other CPUs (such as those from the x86
  family, which you may be using) have instructions that can be a variable
  length.
</p>
<p>
  Second, each family of compatible CPUs (e.g. x86, Arm64) has its own machine
  language, and this machine language is not compatible with the machine
  language of other CPU families. This means machine language programs written
  for one CPU family cannot be run on CPUs from a different family!
</p>
<div class="cpp-note cpp-lightgraybackground" data-ezoic-video-excluded="1">
  <p class="cpp-note-title cpp-bottomline">Related content</p>
  <p>
    A “CPU family” is formally called an “instruction set architecture” (“ISA”
    for short). Wikipedia has a list of different CPU families
    <a
      href="https://en.wikipedia.org/wiki/Comparison_of_instruction_set_architectures#Instruction_sets"
      >here</a
    >.
  </p>
</div>
<p
  class="cpp-section cpp-topline"
  style="clear: both"
  data-ezoic-video-excluded="1"
>
  Assembly Languages
</p>
<div class="code-block code-block-4" style="margin: 8px 0; clear: both"></div>
<p>
  Machine language instructions (like <code>10110000 01100001</code>) are ideal
  for a CPU, but are difficult for humans to understand. Since programs (at
  least historically) have been written and maintained by humans, it makes sense
  that programming languages should be designed with human needs in mind.
</p>
<p>
  An <strong>assembly language</strong> (often called
  <strong>assembly</strong> for short) is a programming language that
  essentially functions as a more human-readable machine language. Here is the
  same instruction as above in x86 assembly language: <code>mov al, 0x61</code>.
</p>
<div class="cpp-note cpp-lightgraybackground" data-ezoic-video-excluded="1">
  <p class="cpp-note-title cpp-bottomline">Optional reading</p>
  <p>
    This instruction illustrates many of the capabilities that make assembly
    more readable than machine language.
  </p>
  <ul>
    <li>
      The operation (what the instruction does) is identified by a short
      mnemonic (typically a 3-5 letter name). <code>mov</code> is easily
      understood to be a mnemonic for “move”, which is an operation that copies
      bits from one location to another.
    </li>
    <li>
      Registers (fast memory locations that are part of the CPU itself) are
      accessed by a name. <code>al</code> is the name of a specific register on
      an x86 CPU.
    </li>
    <li>
      Numbers can be specified in a more convenient format. Assembly languages
      typically support both decimal numbers (e.g. <code>97</code>) and
      hexadecimal numbers (e.g. <code>0x61</code>).
    </li>
  </ul>
  <p>
    It is fairly easy to understand that the assembly instruction
    <code>mov al, 0x61</code> copies hexadecimal number <code>0x61</code> into
    the <code>al</code> CPU register.
  </p>
</div>
<p>
  Since CPUs do not understand assembly language, assembly programs must be
  translated into machine language before they can be executed. This translation
  is done by a program called an <strong>assembler</strong>. Because each
  assembly language instruction is typically designed to mirror an equivalent
  machine language instruction, the translation process is typically
  straightforward.
</p>
<p>
  Just like each CPU family has its own machine language, each CPU family also
  has its own assembly language (which is designed to be assembled into machine
  language for that same CPU family). This means there are many different
  assembly languages. Although conceptually similar, different assembly
  languages support different instructions, use different naming conventions,
  etc…
</p>
<p
  class="cpp-section cpp-topline"
  style="clear: both"
  data-ezoic-video-excluded="1"
>
  Introduction to low-level languages
</p>
<p>
  Machine languages and assembly languages are considered low-level languages,
  as these languages provide minimal abstraction from the architecture of the
  machine. In other words, the programming language itself is tailored to the
  specific instruction set architecture it will be run on.
</p>
<div class="code-block code-block-5" style="margin: 8px 0; clear: both"></div>
<p>Low-level languages have a number of notable downsides:</p>
<ul>
  <li>
    Programs written in a low-level language are not portable. Since a low-level
    language is tailored to a specific instruction set architecture, the
    programs written in the language are too. Porting such programs to other
    architectures is typically non-trivial.
  </li>
  <li>
    Writing a program in a low-level language requires detailed knowledge of the
    architecture itself. For instance, the instruction
    <code>mov al, 061h</code> requires knowing that <code>al</code> refers to a
    CPU register available on this specific platform, and understanding how to
    work with that register. On a different architecture, this register might be
    named something different, have different limitations, or not exist at all.
  </li>
  <li>
    Low-level programs are hard to understand. While individual assembly
    instructions can be quite understandable, it can still be hard to deduce
    what a section of assembly code is actually doing. And since assembly
    programs require many instructions to do even simple tasks, they tend to be
    quite long
  </li>
  <li>
    It is hard to write assembly programs of significant complexity because the
    language only provides primitive capabilities. The programmer is left to
    implement everything they need themselves.
  </li>
</ul>
<p>
  The primary benefit of low-level languages is that they are fast. Assembly is
  still used today when there are sections of code that are performance
  critical. And it’s also used in a few other cases, one of which we’ll discuss
  in a moment.
</p>
<p
  class="cpp-section cpp-topline"
  style="clear: both"
  data-ezoic-video-excluded="1"
>
  Introduction to high-level Languages
</p>
<p>
  To address many of the above downsides, new “high-level” programming languages
  such as C, C++, Pascal (and later, languages such as Java, Javascript, and
  Perl) were developed.
</p>
<p>Here is the same instruction as above in C/C++: <code>a = 97;</code>.</p>
<p>
  Much like assembly programs (which must be assembled to machine language),
  programs written in a high-level language must be translated into machine
  language before they can be run. There are two primary ways this is done:
  compiling and interpreting.
</p>
<div class="code-block code-block-6" style="margin: 8px 0; clear: both"></div>
<p>
  C++ programs are usually compiled. A <strong>compiler</strong> is a program
  (or collection of programs) that reads the source code of one language
  (usually a high-level language) and translates it into another language
  (usually a low-level language). For example, a C++ compiler translates C++
  source code into machine code.
</p>
<div class="cpp-note cpp-lightgraybackground" data-ezoic-video-excluded="1">
  <p class="cpp-note-title cpp-bottomline">Optional reading</p>
  <p>
    Most C++ compilers can also be configured to generate assembly code. This is
    useful when a programmer wants to see what specific instructions the
    compiler is generating for a section of the program.
  </p>
</div>
<p>
  The machine code output by the compiler can then be packaged into an
  executable file (containing machine language instructions) that can
  distributed to others and launched by the operating system. Notably, running
  the executable file does not require the compiler to be installed.
</p>
<p>
  In the beginning, compilers were primitive and produced slow, unoptimized
  assembly or machine code. However, over the years, compilers have become very
  good at producing fast, optimized code, and in some cases can do a better job
  than humans can!
</p>
<p>Here is a simplified representation of the compiling process:</p>
<div class="cpp-image-wrapper">
  <img
    src="https://www.learncpp.com/images/CppTutorial/Chapter0/Compiling-min.png"
    alt="Example of compiling"
  />
</div>
<p>
  Alternatively, an <strong>interpreter</strong> is a program that directly
  executes the instructions in the source code without requiring them to be
  compiled first. Interpreters tend to be more flexible than compilers, but are
  less efficient when running programs because the interpreting process needs to
  be done every time the program is run. This also means the interpreter must be
  installed on every machine where an interpreted program will be run.
</p>
<div class="code-block code-block-7" style="margin: 8px 0; clear: both"></div>
<p>Here is a simplified representation of the interpretation process:</p>
<div class="cpp-image-wrapper">
  <img
    src="https://www.learncpp.com/images/CppTutorial/Chapter0/Interpreting-min.png"
    alt="Example of interpreting"
  />
</div>
<div class="cpp-note cpp-lightgraybackground" data-ezoic-video-excluded="1">
  <p class="cpp-note-title cpp-bottomline">Optional reading</p>
  <p>
    A good comparison of the advantages of compilers vs interpreters can be
    found <a href="https://stackoverflow.com/a/38491646">here</a>.
  </p>
  <p>
    Another advantage of compiled programs is that distributing a compiled
    program does not require distributing the source code. In a non-open-source
    environment, this is important for intellectual property (IP) protection
    purposes.
  </p>
</div>
<p>
  Most high-level languages can be either compiled or interpreted.
  Traditionally, high-level languages like C, C++, and Pascal are compiled,
  whereas “scripting” languages like Perl and Javascript tend to be interpreted.
  Some languages, like Java, use a mix of the two. We’ll explore C++ compilers
  in more detail shortly.
</p>
<p
  class="cpp-section cpp-topline"
  style="clear: both"
  data-ezoic-video-excluded="1"
>
  The benefits of high-level languages
</p>
<p>
  High-level languages are named as such because they provide a high level of
  abstraction from the underlying architecture.
</p>
<p>
  Consider the instruction <code>a = 97;</code>. This instruction lets us store
  the value <code>97</code> somewhere in memory, without needing to know exactly
  where that value will be placed, or what specific machine code instruction is
  needed by the CPU to store that value. In fact, there is nothing
  platform-specific about this instruction at all. The compiler does all the
  work to figure out how this C++ instruction translates into platform-specific
  machine code.
</p>
<div class="code-block code-block-8" style="margin: 8px 0; clear: both"></div>
<p>
  High-level languages allow programmers to write programs without knowing much
  about the platform it will be run on. This not only makes programs easier to
  write, it also makes them significantly more portable. If we’re careful, we
  can write a single C++ that will compile on every platform that has a C++
  compiler! A program that is designed to run on multiple platforms is said to
  be <strong>cross-platform</strong>.
</p>
<div class="cpp-image-wrapper">
  <img
    src="https://www.learncpp.com/images/CppTutorial/Chapter0/Portability-min.png"
    alt="Example of portability"
  />
</div>
<div class="cpp-note cpp-lightgraybackground" data-ezoic-video-excluded="1">
  <p class="cpp-note-title cpp-bottomline">For advanced readers</p>
  <p>
    The following is a partial list of things that can inhibit the portability
    of your C++ code:
  </p>
  <ul>
    <li>
      Many operating systems, such as Microsoft Windows, offer platform-specific
      capabilities that you can use in your code. These can make it much easier
      to write a program for a specific operating system, or provide deeper
      integration with that operating system than would otherwise be possible.
    </li>
    <li>
      Many third-party libraries are only available on certain platforms. If you
      use one of these, you will be limited to the platforms for which that
      library is supported.
    </li>
    <li>
      Some compilers support compiler-specific extensions, which are
      capabilities that are only available in that compiler. If you use these,
      your programs won’t be able to be compiled by other compilers that don’t
      support the same extensions without modification. We’ll talk more about
      these later, once you’ve installed a compiler.
    </li>
    <li>
      In certain cases, the C++ language allows the compiler to determine how
      something should behave. We discuss this further in lesson
      <a
        href="https://www.learncpp.com/cpp-tutorial/uninitialized-variables-and-undefined-behavior/"
        >1.6 -- Uninitialized variables and undefined behavior</a
      >
      under “implementation-defined behavior”.
    </li>
  </ul>
  <p>
    If you’re only targeting a single platform, then portability may not matter
    that much. But many applications these days target multiple platforms in
    order to widen their reach. For example, a mobile app will probably want to
    target both iOS and Android.
  </p>
  <p>
    Even if portability doesn’t seem useful initially, many applications that
    initially targeted a single platform (e.g. PC) decided to port to other
    platforms (e.g. Mac and various consoles) after seeing some level of success
    and interest. If you don’t start with portability in mind, it will be more
    work to port your application later.
  </p>
</div>
<p>
  In these tutorials, we will avoid platform-specific code as much as possible,
  so that our programs will run on any platform that has a modern C++ compiler.
</p>
<p>High-level languages have other benefits as well:</p>
<ul>
  <li>
    Programs written in a high-level language are easier to read, write, and
    learn because their instructions more closely resemble the natural language
    and mathematics that we use every day. In many cases, high-level languages
    require fewer instructions to perform the same tasks as low-level languages.
    For example, in C++ you can write <code>a = b * 2 + 5;</code> in one line.
    In assembly language, this would take 4 to 6 different instructions. This
    makes programs written using high-level languages more concise, which makes
    them easier to understand.
  </li>
  <li>
    High-level languages typically include additional capabilities that make it
    easier to perform common programming tasks, such as requesting a block of
    memory or manipulating text. For example, it only takes a single instruction
    to determine whether the characters “abc” exist within a large block of text
    (and if so, how many characters has to be examined until “abc” was found).
    This can dramatically reduce complexity and development times.
  </li>
</ul>
<div class="cpp-note cpp-lightgraybackground" data-ezoic-video-excluded="1">
  <p class="cpp-note-title cpp-bottomline">Nomenclature</p>
  <p>
    Although C++ is technically considered a high-level language, newer
    programming languages (e.g. scripting languages) provide an even higher
    level of abstraction. As such, C++ is sometimes inaccurately called a
    “low-level language” in comparison.
  </p>
</div>
<div class="cpp-note cpp-lightgraybackground" data-ezoic-video-excluded="1">
  <p class="cpp-note-title cpp-bottomline">Author’s note</p>
  <p>
    Today, C++ would probably be more accurately described as a mid-level
    language. However, this also highlights one of C++’s key strengths: it often
    provides the ability to work at different levels of abstraction. You can
    choose to operate at a lower level for better performance and precision, or
    at a higher level for greater convenience and simplicity.
  </p>
</div>
<p
  class="cpp-section cpp-topline"
  style="clear: both"
  data-ezoic-video-excluded="1"
>
  Rules, Best practices, and warnings
</p>
<p>
  As we proceed through these tutorials, we’ll highlight many important points
  under the following three categories:
</p>
<div class="cpp-note cpp-lightpurplebackground" data-ezoic-video-excluded="1">
  <p class="cpp-note-title cpp-bottomline">Rule</p>
  <p>
    Rules are instructions that you <em>must</em> do, as required by the
    language. Failure to abide by a rule will generally result in your program
    not working.
  </p>
</div>
<div class="cpp-note cpp-lightgreenbackground" data-ezoic-video-excluded="1">
  <p class="cpp-note-title cpp-bottomline">Best practice</p>
  <p>
    Best practices are things that you <em>should</em> do, because that way of
    doing things is either conventional (idiomatic) or recommended. That is,
    either everybody does it that way (and if you do otherwise, you’ll be doing
    something people don’t expect), or it is generally superior to the
    alternatives.
  </p>
</div>
<div class="cpp-note cpp-lightredbackground" data-ezoic-video-excluded="1">
  <p class="cpp-note-title cpp-bottomline">Warning</p>
  <p>
    Warnings are things that you <em>should not</em> do, because they will
    generally lead to unexpected results.
  </p>
</div>
<div class="prevnext">
  <div class="prevnext-inline">
    <a
      class="nav-link"
      href="https://www.learncpp.com/cpp-tutorial/introduction-to-cplusplus/"
      ><div class="nav-button nav-button-next">
        <div class="nav-button-icon">
          <i class="fa fa-chevron-circle-right" aria-hidden="true"></i>
        </div>
        <div class="nav-button-text">
          <div class="nav-button-title">Next lesson</div>
          <div class="nav-button-lesson">
            <span class="nav-button-lesson-number">0.3</span>Introduction to
            C/C++
          </div>
        </div>
      </div></a
    ><a class="nav-link" href="/"
      ><div class="nav-button nav-button-index">
        <div class="nav-button-icon">
          <i class="fa fa-home" aria-hidden="true"></i>
        </div>
        <div class="nav-button-text">
          <div class="nav-button-title">Back to table of contents</div>
        </div>
      </div></a
    ><a
      class="nav-link"
      href="https://www.learncpp.com/cpp-tutorial/introduction-to-these-tutorials/"
      ><div class="nav-button nav-button-prev">
        <div class="nav-button-icon">
          <i class="fa fa-chevron-circle-left" aria-hidden="true"></i>
        </div>
        <div class="nav-button-text">
          <div class="nav-button-title">Previous lesson</div>
          <div class="nav-button-lesson">
            <span class="nav-button-lesson-number">0.1</span>Introduction to
            these tutorials
          </div>
        </div>
      </div></a
    >
  </div>
</div>
<div class="code-block code-block-10" style="margin: 8px 0; clear: both"></div>
